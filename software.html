
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Team Sidescroller - Home</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
      <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
                    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">
                                   <link rel="shortcut icon" href="../assets/ico/favicon.png">
  </head>

  <body>

    <div class="container-narrow">
      <div class="container-content">
        <div class="masthead">
          <ul class="nav nav-pills pull-right">
            <li><a href="index.html">Home</a></li>
            <li><a href="overview.html">Overview</a></li>
            <li class="dropdown active">
              <a class="dropdown-toggle" id="drop4" role="button" data-toggle="dropdown" href="#">Subsystems <b class="caret"></b></a>
              <ul id="menu1" class="dropdown-menu" role="menu" aria-labelledby="drop4">
                <li role="presentation"><a role="menuitem" tabindex="-1" href="mechanical.html">Mechanical</a></li>
                <li role="presentation"><a role="menuitem" tabindex="-1" href="electrical.html">Electrical</a></li>
                <li role="presentation"><a role="menuitem" tabindex="-1" href="software.html">Software</a></li>
              </ul>
            </li>
            <li><a href="budget.html">Budget</a></li>
            <li><a href="about.html">About the Team</a></li>
          </ul>
          <h3>Mechanical Sidescroller</h3>
        </div>

        <hr>



        <h1>Software</h1>
        <div class="row-fluid marketing">
          <div class="span12">
            <h2>Computer Vision</h2>
            <p>One of our objectives was to be able to interpret maps dynamically. That way, rather than having to program in one hard-coded map, the user can just draw a map themselves.</p>
            <p>To this end, we decided to use a webcam and SimpleCV (a Python wrapper around the OpenCV library for C) to detect the contours drawn on the roll of paper.</p>
            <h4>Calibration</h4>
            <p>Our software has two modes: calibration and detection. In calibration, it looks for 4 pink squares and uses those as the bounding box for the map (so that during detection, the image size is as small as possible to facilitate speed and eliminate noise). SimpleCV's findBlobs() and isSquare methods() worked well for this step.</p>
            <div class="row-fluid">
              <div class="span4 center">
                <img src="img/cv1.png">
                <p>Raw image</p>
              </div>
              <div class="span4 center">
                <img src="img/cv2.png">
                <p>Squares found (marked in green)</p>
              </div>
              <div class="span4 center">
                <img src="img/cv3.png">
                <p>Calibrating the working area (shaded grey)</p>
              </div>
            </div>
            <h4>Detection</h4>
            <p>During detection, the software uses Canny threshold detection (via SimpleCV's edges() method)to find the edges in the image, and produces a matrix of points based on the result. These points define boundaries that the character cannot travel through, and are passed on to the game engine, so that it can determine if the character has lost or not.</p>
            <div class="row-fluid">
              <div class="span4 center offset2">
                <img src="img/cv4.png">
                <p>Cropped image</p>
              </div>
              <div class="span4 center">
                <img src="img/cv5.png">
                <p>Edges detected</p>
              </div>
            </div>
            <p>The hardest part about this step was figuring out good lower and upper bounds for the Canny algorithm - too far one way and we got too much noise, but too far the other way and the software didn't pick up our lines. The numbers that we're using right now are th1=20 and th2=40 for the lower and upper bounds. As you can see above, these work quite well.</p>
          </div>
        </div>
        <div class="row-fluid marketing">
          <div class="span8">
            <h2>Game Engine</h2>

            <p>The game engine subsystem is written in Python using the the TKInter graphics library. We chose to use Python and TKInter to facilitate rapid iteration and incremental development. The game engine defines the environment for the game and facilitates user input.</p>
            <p>To make sure we had a demoable prototype and to facilitate testing, the game engine was designed to facilitate both software and mechanical implementations. For each major component, there exists an abstract class defining methods relevant for both implementations, and both a mechanical and software child class. Mechanical and software game-player take these objects to manage the system.</p>
            <p>The software mock-up of the game is completely functional and incorporates all major components we sought to included in the game design-- collision detection, increased speed over time, power-ups and anti-power-ups.  The mechanical implementation of the game engine is also complete; however, due to time constraints and trouble with integration, it has not been largely implemented in our final mechanical product.</p>

            <h2>Process reflection and advice</h2>

            <p>I built the game engine system incrementally.  I started by development general code that could be applied to both the hardware and software systems.  This code included methods defining the basic classes for the world, snail, and power-ups and provided methods to instanciate them.  Next, I built the software mock-up of our physical game. In addition to building on the generic game methods, this code also provided methods to generate a world and continue to build on it dynamically throughout the course of the game.  These components are not necessary in the mechanical implementation, in which the world is provided.  After building the software implementation, I made the mechanical implementation. The mechanical implementation contained methods and interfaces to integrate with the vision and Raspberry Pi systems.   Unfortunately, this system was not fully integrated with the game engine due to time constraints.</p>

            <p>Were I to reimagine my design process, I would have tried to integrate the game engine with other components earlier.  For example, I would have integrated the vision component with the software mock-up rather than waiting until the mechanical system was ready.</p>
          </div>
          <div class="span4">
            <br><br><br>
            <img src="img/gameimage.png">
          </div>
        </div>
        <hr>

        <div class="footer">
          <p>&copy; Olin College 2013</p>
        </div>
      </div>
    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="js/bootstrap.js"></script>
    

  </body>
</html>
